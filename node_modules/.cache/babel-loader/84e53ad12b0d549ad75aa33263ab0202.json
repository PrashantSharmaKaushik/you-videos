{"ast":null,"code":"'use strict';\n/*\n * cls-bluebird\n * Module entry point\n */\n// Modules\n\nvar isBluebird = require('is-bluebird'); // Require Bluebird library\n// Ignore errors if cannot be required\n\n\nvar Bluebird;\n\ntry {\n  Bluebird = require('bluebird');\n} catch (err) {} // Imports\n\n\nvar shimMethod = require('./shimMethod'),\n    shimOnCancel = require('./shimOnCancel'),\n    shimCall = require('./shimCall'),\n    shimUsing = require('./shimUsing'),\n    shimCoroutine = require('./shimCoroutine'); // Exports\n\n/**\n * Patch bluebird to run maintain CLS context for a specific namespace.\n * If a Bluebird Promise constructor is provided, it is patched.\n * If not provided, the version returned by `require('bluebird')` is used.\n *\n * @param {Object} ns - CLS namespace object\n * @param {Function} [Promise] - Bluebird Promise constructor to patch (optional)\n * @returns {Function} - Bluebird Promise constructor\n * @throws {TypeError} - If `ns` or `Promise` are not of correct type\n * @throws {Error} - If `Promise` not provided and cannot require `bluebird` module\n */\n\n\nmodule.exports = function patchBluebird(ns, Promise) {\n  // Check namespace is valid\n  if (!ns || typeof ns !== 'object' || typeof ns.bind !== 'function' || typeof ns.run !== 'function') throw new TypeError('Must provide CLS namespace to patch Bluebird against'); // Check Promise implementation is some variation of Bluebird\n  // If none provided, use default Bluebird\n\n  if (!Promise) {\n    Promise = Bluebird;\n    if (!Promise) throw new Error('Could not require Bluebird');\n  } else if (!isBluebird.ctor(Promise)) {\n    throw new TypeError('Promise implementation provided must be Bluebird');\n  } // Patch all methods to carry CLS context\n\n\n  var v3 = isBluebird.ctor.v3(Promise);\n  /*\n   * Core\n   *\n   * Not patched as always run callback synchronously:\n   *   new Promise()\n   *   Promise.try() / Promise.attempt()\n   *\n   * Not patched as do not take a callback:\n   *   Promise.bind() / .bind()\n   *   Promise.resolve() / Promise.fulfilled() / Promise.cast()\n   *   Promise.reject() / Promise.rejected()\n   *\n   * Not patched as call another patched method synchronously\n   *   .error() - calls .catch()\n   *\n   * Not patched as are wrappers:\n   *   Promise.method()\n   *\n   * NB Due to bug in bluebird v2 https://github.com/petkaantonov/bluebird/issues/1153\n   * `Promise.join()` calls the callback synchronously if input is only values or\n   * resolved promises, but async if any promises are pending.\n   * So handler is sometimes bound to CLS context unnecessarily, but this does no harm\n   * beyond the very slight performance overhead of an extra `ns.bind()` call.\n   */\n\n  shimProto('then', v3 ? [0, 1] : [0, 1, 2]);\n  shimProto('spread', v3 ? [0] : [0, 1]);\n  shimProto('finally', [0]);\n  Promise.prototype.lastly = Promise.prototype.finally;\n  shimStatic('join', [-1]);\n\n  if (!v3) {\n    // Only patched in bluebird v2.\n    // In bluebird v3 `.catch()` calls `.then()` immediately which binds callback.\n    shimProto('catch', [-1]);\n    Promise.prototype.caught = Promise.prototype.catch;\n  }\n  /*\n   * Synchronous inspection\n   *\n   * Not patched as do not take a callback:\n   *   .isFulfilled()\n   *   .isRejected()\n   *   .isPending()\n   *   .isCancelled()\n   *   .isResolved()\n   *   .value()\n   *   .reason()\n   *   .reflect()\n   */\n\n  /*\n   * Collections\n   *\n   * Not patched as do not take a callback:\n   *   Promise.all() / .all()\n   *   Promise.props() / .props()\n   *   Promise.any() / .any()\n   *   Promise.some() / .some()\n   *   Promise.race() / .race()\n   */\n\n\n  shimBoth('map', [0]);\n  shimBoth('filter', [0]);\n  shimBoth('reduce', [0]);\n  shimBoth('each', [0]); // In bluebird v2, there is no `Promise.mapSeries()`/`.mapSeries()` method\n\n  if (v3) shimBoth('mapSeries', [0]);\n  /*\n   * Resource management\n   *\n   * NB disposer callbacks are bound to context at time disposer created, not when utilized in `using()`\n   */\n\n  shimUsing(Promise, ns, v3); // shims `Promise.using()`\n\n  shimProto('disposer', [0]);\n  /*\n   * Promisification\n   *\n   * Not patched as always run callback synchronously:\n   *   Promise.fromCallback()\n   *   Promise.fromNode()\n   *\n   * Not patched as they are wrappers:\n   *   Promise.promisify()\n   *   Promise.promisifyAll()\n   */\n\n  shimProto('asCallback', [0]);\n  Promise.prototype.nodeify = Promise.prototype.asCallback;\n  /*\n   * Timers\n   *\n   * Not patched as do not take a callback:\n   *   Promise.delay() / .delay()\n   *   .timeout()\n   */\n\n  /*\n   * Cancellation\n   *\n   * Not patched as does not take a callback:\n   *   .cancel() / .break()\n   *   .isCancellable()\n   *   .cancellable() (bluebird v2 only)\n   *   .uncancellable() (bluebird v2 only)\n   *\n   * NB In bluebird v3 `onCancel` handler will be called\n   * in CLS context of call to `onCancel()`.\n   */\n  // Patch `Promise.prototype._resolveFromExecutor`\n  // in order to patch `onCancel` handler in `new Promise()`.\n\n  if (v3) shimOnCancel(Promise, ns);\n  /*\n   * Generators\n   *\n   * Not patched as does not take a callback:\n   *   Promise.coroutine.addYieldHandler()\n   *\n   * NB `options.yieldHandler` will run in whatever CLS context is active at time of `yield`\n   */\n\n  var addYieldHandler = Promise.coroutine.addYieldHandler;\n  shimCoroutine('coroutine', Promise, ns, v3); // shims `Promise.coroutine()`\n\n  Promise.coroutine.addYieldHandler = addYieldHandler;\n  /*\n   * Utility\n   *\n   * Not patched as do not take a callback:\n   *   .get()\n   *   .return() / .thenReturn()\n   *   .throw() / .thenThrow()\n   *   .catchReturn()\n   *   .catchThrow()\n   *   Promise.getNewLibraryCopy()\n   *   Promise.noConflict()\n   *   Promise.setScheduler()\n   */\n\n  shimProto('tap', [0]);\n  if (v3) shimProto('tapCatch', [-1]);\n  shimCall(Promise, ns); // shims `.call()`\n\n  /*\n   * Configuration\n   *\n   * Not patched as do not take a callback:\n   *   Promise.config()\n   *   .suppressUnhandledRejections()\n   *   Promise.longStackTraces()\n   *   Promise.hasLongStackTraces()\n   *\n   * Not patched as meaningless to do so:\n   *   Promise.onPossiblyUnhandledRejection()\n   *   Promise.onUnhandledRejectionHandled()\n   *\n   * NB Error handlers will run with unknown CLS context.\n   * CLS context should not be relied upon to be the context at the time error was thrown.\n   * Catch errors with `.catch()` instead!\n   */\n\n  shimProto('done', v3 ? [0, 1] : [0, 1, 2]);\n  /*\n   * Progression (bluebird v2 only)\n   */\n\n  if (!v3) shimProto('progressed', [0]);\n  /*\n   * Undocumented\n   *\n   * Not patched as do not take a callback:\n   *   Promise.is()\n   *   Promise.settle() / .settle()\n   *   Promise.defer() / Promise.pending()\n   *   .toString()\n   *   .toJSON()\n   */\n  // `.fork()` does not exist in bluebird v3\n\n  if (!v3) shimProto('fork', [0, 1, 2]);\n  shimCoroutine('spawn', Promise, ns, v3); // shims `Promise.spawn()`\n  // Return patched Bluebird constructor\n\n  return Promise;\n  /*\n   * Patching functions\n   */\n\n  function shimStatic(methodName, args) {\n    shimMethod(Promise, methodName, args, ns);\n  }\n\n  function shimProto(methodName, args) {\n    shimMethod(Promise.prototype, methodName, args, ns);\n  }\n\n  function shimBoth(methodName, args) {\n    shimProto(methodName, args);\n    shimStatic(methodName, args.map(function (arg) {\n      return arg < 0 ? arg : arg + 1;\n    }));\n  }\n};","map":null,"metadata":{},"sourceType":"script"}